# Budget Zero - Complete Platform Plan

## 1. Executive Summary

Budget Zero is a collaborative game development platform that connects creative professionals to build tabletop games through milestone-driven crowdfunding. The platform enables creators to start with just an idea and incrementally grow their project by attracting skilled contributors and community funding at each development stage.

### Core Value Proposition
- **For Creators**: Transform game ideas into published products with zero upfront investment
- **For Contributors**: Join exciting projects, build portfolio, earn compensation through flexible arrangements
- **For Fans**: Support projects from inception, receive exclusive content, and influence development
- **For Industry**: Democratize game development and discover new talent

## 2. How Budget Zero Works

### Project Lifecycle

**1. Idea Stage**
- Creator posts a game concept with basic description and vision
- Community can vote and provide feedback
- Minimum engagement threshold required to advance

**2. Milestone-Driven Development**
Budget Zero uses incremental milestones to grow projects organically:

- **Milestone 1: Core Mechanics** - Creator develops basic game rules
- **Milestone 2: Story Development** - Add writer for narrative elements
- **Milestone 3: Visual Design** - Add illustrator for artwork and visual identity
- **Milestone 4: 3D Assets** - Add sculptor for miniatures and physical components
- **Milestone 5: Production Ready** - Add graphic designer for final layout and print-ready files
- **Milestone 6: Playtesting** - Form playtester groups and refine gameplay
- **Milestone 7: Publishing** - Finalize for manufacturing and distribution

### Milestone Mechanics

Each milestone includes:
- **Funding Goal**: Amount needed to compensate contributors and cover costs
- **Deliverables**: Specific outputs expected (artwork, rules, prototypes, etc.)
- **Timeline**: Expected completion timeframe
- **Contributor Requirements**: Skills and experience needed
- **Community Benefits**: Exclusive content or early access for supporters

### Collaboration & Compensation

**Flexible Arrangements** (all publicly transparent):
- **Equity Share**: Percentage of future revenue
- **Fixed Payment**: One-time compensation for deliverables
- **Royalty Agreement**: Ongoing percentage of sales
- **Credit & Portfolio**: Attribution and portfolio building
- **Hybrid Models**: Combination of above approaches

**Public Transparency**:
- All contributor agreements are publicly viewable
- Funding sources and allocation clearly displayed
- Community can see how money flows through the project

### Community Features

#### Milestone Discussions
- **Dedicated Discussion Threads**: Each milestone has its own comment section
- **Comment Categories**: General, Application, Feedback, Question, Suggestion, Support, Concern
- **Contributor Q&A**: Potential contributors can ask questions before applying
- **Community Input**: Backers and fans can provide feedback on milestone direction
- **Pinned Comments**: Important announcements and FAQs highlighted by creators
- **Real-time Updates**: Live notifications for new comments and responses
- **Privacy Controls**: Public comments vs contributor-only discussions

#### Community Recommendation System
- **Milestone Suggestions**: Community can propose next steps for projects
- **Collaborator Recommendations**: Users can suggest specific people for milestones
- **Service Recommendations**: Suggest printers, manufacturers, or service providers
- **Tool & Resource Suggestions**: Recommend software, assets, or educational content
- **Community Voting**: Upvote/downvote recommendations to surface the best ideas
- **Creator Response System**: Creators can accept, reject, or request more info
- **Reasoning Required**: All recommendations must include detailed reasoning
- **Discussion Threads**: Each recommendation has its own comment section
- **Notification System**: Creators notified of highly-voted recommendations

### Publishing Options

Upon completion, projects can:
- **Platform Publishing**: Direct sales through Budget Zero marketplace
- **Print & Play**: Digital downloads for home printing
- **Print on Demand**: Individual copy fulfillment through integrated services
- **Kickstarter Launch**: Export to major crowdfunding platforms
- **Manufacturing Partnerships**: Connect with established game publishers

## 3. Digital Marketplace

### Marketplace Overview
Budget Zero's integrated marketplace allows users to purchase and download completed games in digital formats, including print-and-play files, STL files for 3D printing, and digital rulebooks. This creates a direct path from collaborative development to consumer sales while maintaining the platform's community-driven ethos.

### Product Types & Formats

**Print & Play Packages**
- **Complete Game Sets**: Full rulebooks, cards, boards, and tokens as PDFs
- **Component Packs**: Individual game components (cards only, boards only, etc.)
- **Print-Optimized Files**: Multiple paper sizes (A4, Letter, A3) and printer types
- **Accessibility Versions**: High-contrast, large-text, and colorblind-friendly variants
- **Language Packs**: Translated versions created by community contributors

**3D Printable Assets**
- **STL File Collections**: Miniatures, tokens, dice, and game components
- **Multi-Resolution Files**: Different quality levels for various 3D printers
- **Supported/Unsupported Versions**: Files optimized for different printer capabilities
- **Print Settings Guides**: Recommended settings and materials for best results
- **Remix-Friendly Licenses**: Open licensing for community modifications

**Digital Resources**
- **Interactive Rulebooks**: Searchable PDFs with bookmarks and hyperlinks
- **Reference Sheets**: Quick-reference cards and player aids
- **Digital Companions**: Apps or web tools for game management
- **Audio Content**: Soundtrack, sound effects, or narrated rules
- **Video Tutorials**: How-to-play videos and strategy guides

### Marketplace Features

**Creator Benefits**
- **Product Publishing**: Easy upload and description tools for finished games
- **Pricing Control**: Flexible pricing with suggested ranges based on content
- **Sales Analytics**: Revenue tracking, download statistics, and customer feedback
- **Revenue Splits**: Transparent distribution among all project collaborators
- **Promotional Tools**: Discount codes, bundle creation, and featured placement

**Customer Experience**
- **Instant Downloads**: Immediate access to purchased files via secure download links
- **Purchase History**: Library of all owned games with re-download capabilities
- **Wishlist System**: Save games for later purchase and get notified of sales
- **Review System**: Rate and review purchased games to help other customers
- **Support Integration**: Direct access to creators for technical issues

## 4. User Experience & Platform Features

### User Journey Flows

#### Creator Journey
1. **Invite & Onboarding**
   - Receive invite code from existing user or approve invite request
   - Land on exclusive invite-only signup page with personalized welcome
   - Complete detailed profile with bio, location, and primary profession
   - Upload 3-5 portfolio items showcasing previous work and experience

2. **Project Creation**
   - Create project with guided form: basic info, game details, target audience
   - Upload concept art, sketches, or prototype images
   - Set project visibility (public, private, or draft)

3. **Community Building**
   - Share project on social media with generated preview cards
   - Engage with early supporters through comments and updates
   - Build email list of interested followers

4. **Milestone Management**
   - Create detailed milestone with funding goals and deliverables
   - Enable discussion threads and set privacy levels
   - Review community recommendations and respond to suggestions
   - Review and respond to contributor applications
   - Select contributors and finalize agreements

5. **Project Development**
   - Collaborate with contributors through integrated tools
   - Post regular updates with progress photos/videos
   - Manage asset versions and approvals

6. **Publishing**
   - Finalize all assets and prepare for production
   - Choose publishing path (platform, print-on-demand, Kickstarter)
   - Launch marketing campaign with built-in audience

#### Contributor Journey
1. **Discovery**
   - Browse projects by profession, category, or status
   - Use advanced filters to find relevant opportunities
   - Receive personalized project recommendations

2. **Application Process**
   - Review milestone requirements and compensation
   - Submit application with portfolio samples
   - Propose timeline and compensation preferences

3. **Collaboration**
   - Onboard to project with welcome package
   - Access project resources and communication channels
   - Submit deliverables through integrated review system

4. **Portfolio Building**
   - Showcase completed work in professional portfolio
   - Receive creator testimonials and ratings
   - Build reputation score based on quality and reliability

#### Fan/Backer Journey
1. **Project Discovery**
   - Explore trending and recommended projects
   - Follow favorite creators and categories
   - Receive notifications about new projects and updates

2. **Support & Engagement**
   - Contribute to milestone funding campaigns
   - Choose reward tiers and exclusive content access
   - Participate in polls and community decisions

3. **Community Participation**
   - Join project-specific discussions
   - Participate in playtesting sessions
   - Make recommendations for milestones, collaborators, or services
   - Vote on community suggestions and provide feedback

### Core Platform Features

**Collaborative Rulebook Editor**
- **Real-time Collaborative Editing**: Multiple contributors can edit the rulebook simultaneously
- **Version Control**: Track changes, compare versions, and revert to previous drafts
- **Structured Templates**: Pre-built templates for different game types (board games, card games, RPGs)
- **Component Integration**: Link rules to specific game components (cards, boards, tokens)
- **Playtesting Notes**: Inline comments and suggestions from playtesters
- **PDF Export System**: Professional PDF generation with custom layouts, branding, and print-ready formatting
- **Rule Dependencies**: Visual mapping of how rules interact and depend on each other
- **Glossary Management**: Centralized definition of game terms and mechanics

**Project Management**
- Intuitive project dashboard with progress tracking
- Milestone planning and funding tools with discussion threads
- Asset management with version control
- Team communication and collaboration tools

**Community Features**
- User profiles with portfolios and ratings
- Project discovery with advanced search/filters
- Social features (following, commenting, reactions)
- Real-time notifications and activity feeds

**Payment System**
- Secure escrow for milestone-based payments
- Multiple compensation models (fixed, equity, royalty)
- Automated tax document generation
- Transparent fee structure and reporting

## 5. Data Modeling

### Core Entities

```typescript
User {
    id: string
    email: string
    first_name: string
    last_name: string
    username: string
    bio?: string
    avatar_url?: string
    location?: string
    website?: string
    invited_by_user_id?: string  // Track who invited this user
    invited_by_code?: string  // The specific invite code used
    professions: UserProfession[]
    portfolio_items: PortfolioItem[]
    created_at: date
    updated_at: date
    
    // Relationships
    invite_stats?: UserInviteStats
    sent_invites: Invite[]
    received_rewards: InviteReward[]
}

UserProfession {
    id: string
    user_id: string
    profession_id: string
    skill_level: 'Beginner' | 'Intermediate' | 'Advanced' | 'Expert'
    years_experience: number
    verified: boolean
    created_at: date
}

Profession {
    id: string
    name: 'Game Designer' | 'Illustrator' | 'Sculptor' | 'Rules Writer' | 
          'Graphic Designer' | 'Photographer' | 'Community Manager' | 
          'Voice Actor' | 'Accountant' | 'Marketing Manager' | 'Printer' |
          'Publisher' | 'Sound Designer' | 'Video Editor' | 'Translator' |
          'Educator'
    description: string
    category: 'Creative' | 'Technical' | 'Business' | 'Production' | 'Education'
}

PortfolioItem {
    id: string
    user_id: string
    title: string
    description: string
    images: string[]
    files: string[]
    project_id?: string  // If created through Budget Zero
    external_url?: string
    profession_id: string
    created_at: date
}

Project {
    id: string
    name: string
    description: string
    creator_id: string
    creator: User
    category: 'Board Game' | 'Card Game' | 'RPG' | 'Miniatures' | 'Hybrid'
    status: 'Idea' | 'In Development' | 'In Review' | 'Published' | 'Cancelled'
    target_audience: string
    player_count: string
    play_time: string
    complexity: 'Light' | 'Medium' | 'Heavy'
    current_milestone_id?: string
    total_raised: number
    total_backers: number
    featured_image?: string
    images: string[]
    tags: string[]
    created_at: date
    updated_at: date
    
    // Relationships
    milestones: Milestone[]
    posts: Post[]
    contributions: Contribution[]
    collaborators: ProjectCollaborator[]
    assets: ProjectAsset[]
    comments: Comment[]
    votes: ProjectVote[]
    recommendations: MilestoneRecommendation[]
}

Milestone {
    id: string
    project_id: string
    title: string
    description: string
    funding_goal: number
    current_funding: number
    status: 'Planning' | 'Active' | 'Funded' | 'In Progress' | 'Completed' | 'Failed'
    deadline?: date
    required_profession_id?: string
    deliverables: string[]
    rewards: string[]  // What backers get
    order_index: number
    discussion_enabled: boolean
    allow_public_comments: boolean
    created_at: date
    completed_at?: date
    
    // Relationships
    contributions: Contribution[]
    applications: MilestoneApplication[]
    comments: Comment[]
    selected_contributor_id?: string
}

MilestoneApplication {
    id: string
    milestone_id: string
    user_id: string
    proposal: string
    portfolio_samples: string[]
    compensation_request: number
    compensation_type: 'Fixed' | 'Equity' | 'Royalty' | 'Hybrid'
    timeline_estimate: number  // days
    status: 'Pending' | 'Accepted' | 'Rejected' | 'Withdrawn'
    created_at: date
}

MilestoneRecommendation {
    id: string
    project_id: string
    recommender_id: string
    recommender: User
    title: string
    description: string
    recommendation_type: 'Milestone' | 'Collaborator' | 'Service' | 'Tool' | 'Resource'
    suggested_profession_id?: string
    suggested_user_id?: string  // For collaborator recommendations
    suggested_funding_goal?: number
    suggested_timeline?: number  // days
    reasoning: string
    community_votes: number
    creator_response?: string
    status: 'Pending' | 'Accepted' | 'Rejected' | 'Under Review'
    created_at: date
    responded_at?: date
    
    // Relationships
    votes: RecommendationVote[]
    comments: Comment[]
}

RecommendationVote {
    id: string
    recommendation_id: string
    user_id: string
    vote_type: 'Upvote' | 'Downvote'
    created_at: date
}

ProjectCollaborator {
    id: string
    project_id: string
    user_id: string
    role: string
    compensation_type: 'Fixed' | 'Equity' | 'Royalty' | 'Credit' | 'Hybrid'
    compensation_amount?: number
    equity_percentage?: number
    royalty_percentage?: number
    status: 'Active' | 'Completed' | 'Removed'
    joined_at: date
    contribution_summary: string
}

Contribution {
    id: string
    project_id: string
    milestone_id?: string
    user_id: string
    amount: number
    type: 'Monetary' | 'Time' | 'Resources' | 'Expertise'
    message?: string
    anonymous: boolean
    reward_tier?: string
    status: 'Pending' | 'Confirmed' | 'Refunded'
    stripe_payment_intent_id?: string
    created_at: date
}

Post {
    id: string
    project_id: string
    author_id: string
    title: string
    content: string  // Markdown
    type: 'Update' | 'Milestone' | 'Announcement' | 'Question'
    images: string[]
    files: string[]
    pinned: boolean
    published_at: date
    created_at: date
    updated_at: date
    
    // Relationships
    comments: Comment[]
    reactions: PostReaction[]
}

Comment {
    id: string
    post_id?: string
    project_id?: string
    milestone_id?: string  // For milestone discussions
    recommendation_id?: string  // For recommendation discussions
    parent_comment_id?: string  // For replies
    author_id: string
    content: string
    comment_type: 'General' | 'Application' | 'Feedback' | 'Question' | 'Suggestion' | 'Support' | 'Concern'
    is_pinned: boolean
    created_at: date
    updated_at: date
    
    // Relationships
    replies: Comment[]
    reactions: CommentReaction[]
}

ProjectAsset {
    id: string
    project_id: string
    milestone_id?: string
    contributor_id: string
    name: string
    description?: string
    file_url: string
    file_type: string
    file_size: number
    access_level: 'Public' | 'Backers' | 'Contributors' | 'Private'
    version: string
    created_at: date
}

ProjectVote {
    id: string
    project_id: string
    user_id: string
    vote_type: 'Upvote' | 'Downvote'
    created_at: date
}

PostReaction {
    id: string
    post_id: string
    user_id: string
    reaction: '👍' | '❤️' | '🔥' | '👏' | '😍' | '🎉'
    created_at: date
}

CommentReaction {
    id: string
    comment_id: string
    user_id: string
    reaction: '👍' | '👎' | '❤️' | '😄' | '😢' | '😮' | '😡'
    created_at: date
}

// Digital Marketplace Entities
MarketplaceProduct {
    id: string
    project_id: string
    name: string
    description: string
    price: number
    currency: 'USD' | 'EUR' | 'GBP'
    license_type: 'Standard' | 'Commercial' | 'Creative Commons' | 'Open Source'
    category: 'Complete Game' | 'Components' | 'STL Files' | 'Rulebook' | 'Accessories'
    tags: string[]
    featured_image: string
    gallery_images: string[]
    included_files: ProductFile[]
    print_requirements: PrintRequirement[]
    download_count: number
    rating_average: number
    rating_count: number
    status: 'Draft' | 'Published' | 'Suspended' | 'Archived'
    created_at: date
    updated_at: date
    
    // Relationships
    project: Project
    files: MarketplaceFile[]
    purchases: Purchase[]
    reviews: ProductReview[]
    collaborator_splits: RevenueSplit[]
}

MarketplaceFile {
    id: string
    product_id: string
    filename: string
    file_url: string
    file_type: 'PDF' | 'STL' | 'PNG' | 'SVG' | 'ZIP'
    file_size: number
    description: string
    print_settings?: PrintSettings
    created_at: date
}

Purchase {
    id: string
    user_id: string
    product_id: string
    amount_paid: number
    currency: string
    stripe_payment_intent_id: string
    download_links: DownloadLink[]
    status: 'Completed' | 'Refunded' | 'Failed'
    purchased_at: date
    
    // Relationships
    user: User
    product: MarketplaceProduct
    downloads: Download[]
}

ProductReview {
    id: string
    product_id: string
    user_id: string
    rating: number  // 1-5 stars
    title: string
    content: string
    helpful_votes: number
    verified_purchase: boolean
    created_at: date
    updated_at: date
}

RevenueSplit {
    id: string
    product_id: string
    user_id: string
    split_percentage: number
    role: string  // 'Creator', 'Artist', 'Writer', etc.
    created_at: date
}

PrintRequirement {
    id: string
    name: string
    description: string
    required: boolean
    category: 'Paper' | 'Printer' | 'Materials' | 'Tools'
}

DownloadLink {
    id: string
    purchase_id: string
    file_id: string
    secure_url: string
    expires_at: date
    download_count: number
    max_downloads: number
}

// Invite system entities
Invite {
    id: string
    code: string  // Short, memorable invite codes
    inviter_id: string
    inviter: User
    invite_type: 'Creator' | 'Contributor' | 'General' | 'VIP'
    max_uses: number  // How many times this code can be used
    current_uses: number  // How many times it's been used
    status: 'Active' | 'Exhausted' | 'Expired' | 'Revoked'
    expires_at?: date
    last_used_at?: date
    metadata?: any  // Extra data like special permissions, rewards
    created_at: date
    
    // Relationships
    usages: InviteUsage[]
    rewards: InviteReward[]
}

InviteUsage {
    id: string
    invite_id: string
    inviter_id: string  // Denormalized for faster queries
    invitee_id: string  // Who used the invite
    invitee_email: string  // Email at time of signup
    used_at: date
    ip_address?: string  // For fraud detection
    user_agent?: string  // For analytics
}

InviteReward {
    id: string
    user_id: string
    invite_usage_id?: string
    reward_type: 'InviteCredits' | 'PlatformCredits' | 'Badge' | 'FeatureAccess'
    reward_value?: number  // Amount of credits, days of access, etc.
    reward_data?: any  // Additional reward metadata
    status: 'Pending' | 'Granted' | 'Revoked'
    granted_at?: date
    expires_at?: date
    created_at: date
}

UserInviteStats {
    user_id: string
    total_invites_sent: number
    total_invites_used: number
    successful_signups: number  // Users who completed onboarding
    active_invitees: number  // Invitees still active (30+ days)
    invite_credits_earned: number  // Total credits from invites
    invite_level: number  // Gamification level
    last_invite_sent_at?: date
    updated_at: date
}

InviteRequest {
    id: string
    email: string
    first_name: string
    last_name: string
    profession_id: string
    portfolio_url?: string
    reason: string  // Why they want to join
    referrer?: string  // How they heard about the platform
    status: 'Pending' | 'Approved' | 'Rejected'
    reviewed_by?: string
    review_notes?: string
    created_at: date
    reviewed_at?: date
}

WaitlistEntry {
    id: string
    email: string
    first_name?: string
    last_name?: string
    profession_interests: string[]
    notification_preferences: 'Weekly' | 'Monthly' | 'Launch Only'
    referral_source?: string
    created_at: date
    invited_at?: date
    invite_id?: string
}

// Notification system
Notification {
    id: string
    user_id: string
    type: 'Project Update' | 'Milestone Funded' | 'Application Status' | 
          'New Collaborator' | 'Comment Reply' | 'Project Published'
    title: string
    message: string
    link?: string
    read: boolean
    created_at: date
}

// Collaborative Rulebook System
Rulebook {
    id: string
    project_id: string
    title: string
    description: string
    version: string
    status: 'Draft' | 'Review' | 'Final' | 'Published'
    template_type: 'Board Game' | 'Card Game' | 'RPG' | 'Miniatures' | 'Custom'
    content: string  // Rich text/markdown content
    sections: RulebookSection[]
    collaborators: RulebookCollaborator[]
    created_by: string
    created_at: date
    updated_at: date
    published_at?: date
    
    // Relationships
    versions: RulebookVersion[]
    comments: RulebookComment[]
    components: GameComponent[]
    glossary_terms: GlossaryTerm[]
}

RulebookSection {
    id: string
    rulebook_id: string
    title: string
    content: string
    order_index: number
    parent_section_id?: string  // For nested sections
    section_type: 'Setup' | 'Gameplay' | 'Components' | 'Victory' | 'Variants' | 'Custom'
    is_required: boolean
    created_at: date
    updated_at: date
    
    // Relationships
    subsections: RulebookSection[]
    linked_components: GameComponent[]
    comments: RulebookComment[]
}

RulebookVersion {
    id: string
    rulebook_id: string
    version_number: string
    content_snapshot: string
    change_summary: string
    created_by: string
    created_at: date
    is_major_version: boolean
    
    // Relationships
    changes: RulebookChange[]
}

RulebookChange {
    id: string
    version_id: string
    section_id?: string
    change_type: 'Added' | 'Modified' | 'Deleted' | 'Moved'
    old_content?: string
    new_content?: string
    author_id: string
    timestamp: date
    line_number?: number
}

RulebookCollaborator {
    id: string
    rulebook_id: string
    user_id: string
    permission_level: 'View' | 'Comment' | 'Edit' | 'Admin'
    role: 'Lead Designer' | 'Writer' | 'Editor' | 'Playtester' | 'Reviewer'
    invited_by: string
    joined_at: date
}

RulebookComment {
    id: string
    rulebook_id: string
    section_id?: string
    parent_comment_id?: string
    author_id: string
    content: string
    comment_type: 'General' | 'Suggestion' | 'Clarification' | 'Playtesting' | 'Issue'
    line_number?: number
    character_position?: number
    status: 'Open' | 'Resolved' | 'Dismissed'
    created_at: date
    resolved_at?: date
    resolved_by?: string
    
    // Relationships
    replies: RulebookComment[]
}

GameComponent {
    id: string
    project_id: string
    rulebook_id?: string
    name: string
    component_type: 'Card' | 'Board' | 'Token' | 'Die' | 'Miniature' | 'Tile' | 'Other'
    description: string
    quantity: number
    specifications: any  // JSON for size, material, etc.
    linked_rules: string[]  // References to rulebook sections
    image_url?: string
    created_at: date
    updated_at: date
}

GlossaryTerm {
    id: string
    rulebook_id: string
    term: string
    definition: string
    examples?: string[]
    related_terms: string[]
    first_used_section_id?: string
    created_by: string
    created_at: date
    updated_at: date
}

RulebookTemplate {
    id: string
    name: string
    game_type: 'Board Game' | 'Card Game' | 'RPG' | 'Miniatures' | 'Hybrid'
    description: string
    sections: RulebookTemplateSection[]
    is_official: boolean
    created_by: string
    usage_count: number
    created_at: date
}

RulebookTemplateSection {
    id: string
    template_id: string
    title: string
    description: string
    placeholder_content: string
    order_index: number
    is_required: boolean
    section_type: string
}

// Webhook Integration System for Data Portability
WebhookEndpoint {
    id: string
    user_id: string
    project_id?: string  // If null, applies to all user's projects
    name: string
    url: string
    secret_key: string  // For webhook signature verification
    event_types: WebhookEventType[]
    is_active: boolean
    retry_config: {
        max_retries: number
        retry_delays: number[]  // Exponential backoff delays
    }
    headers: any  // JSON - custom headers to include
    last_successful_delivery?: date
    failure_count: number
    created_at: date
    updated_at: date
}

WebhookDelivery {
    id: string
    endpoint_id: string
    event_type: WebhookEventType
    payload: any  // JSON - complete event data
    payload_signature: string  // HMAC signature for verification
    status: 'Pending' | 'Delivered' | 'Failed' | 'Retrying'
    http_status_code?: number
    response_body?: string
    retry_count: number
    next_retry_at?: date
    delivered_at?: date
    created_at: date
}

WebhookEvent {
    id: string
    event_type: WebhookEventType
    resource_type: 'Project' | 'Milestone' | 'Asset' | 'Payment' | 'User'
    resource_id: string
    user_id: string  // The user this event belongs to
    project_id?: string
    data: any  // JSON - complete resource data + metadata
    timestamp: date
    processed: boolean
}

enum WebhookEventType {
    // Project Events
    'project.created',
    'project.updated', 
    'project.status_changed',
    'project.completed',
    'project.cancelled',
    
    // Milestone Events
    'milestone.created',
    'milestone.funded',
    'milestone.completed',
    'milestone.failed',
    'milestone.updated',
    
    // Asset Events
    'asset.uploaded',
    'asset.updated',
    'asset.deleted',
    'asset.version_created',
    
    // Marketplace Events
    'product.listed',
    'product.sold',
    'product.downloaded',
    'product.updated',
    
    // Collaboration Events
    'collaborator.added',
    'collaborator.removed',
    'collaborator.role_changed',
    
    // Payment Events
    'payment.received',
    'payment.processed',
    'payout.completed',
    'refund.processed',
    
    // Rulebook Events
    'rulebook.published',
    'rulebook.version_created',
    'rulebook.exported'
}

DataExportRequest {
    id: string
    user_id: string
    export_type: 'Complete' | 'Project Specific' | 'Assets Only' | 'Marketplace Data'
    project_ids?: string[]  // If export_type is 'Project Specific'
    include_assets: boolean
    include_metadata: boolean
    include_payment_history: boolean
    format: 'JSON' | 'CSV' | 'ZIP'
    status: 'Requested' | 'Processing' | 'Ready' | 'Downloaded' | 'Expired'
    download_url?: string
    expires_at?: date
    file_size_bytes?: number
    requested_at: date
    completed_at?: date
}

// Platform settings and configuration
PlatformSettings {
    id: string
    key: string
    value: string
    description: string
    updated_at: date
}
```

### Relationships Summary

- **Users** can create multiple **Projects** and contribute to others
- **Projects** progress through **Milestones** with specific funding goals
- **Contributors** apply to **Milestones** and become **ProjectCollaborators**
- **Posts** provide updates and communication channels
- **Assets** store project files with different access levels
- **Contributions** track financial and resource support
- **Comments** and **Reactions** enable community engagement
- **MilestoneRecommendations** allow community input on project direction
- **MarketplaceProducts** enable digital sales of completed games
- **Invites** control platform access during growth phases
- **Rulebooks** are the foundation of each project with collaborative editing
- **RulebookSections** organize rules into structured, manageable parts
- **GameComponents** link directly to specific rules and sections
- **GlossaryTerms** ensure consistent terminology across the rulebook
- **RulebookVersions** track all changes with detailed change logs

## 6. Invite System & Growth Strategy

### Why Invite-Only?

**Quality Control**
- Curate high-quality creators and contributors during beta
- Prevent spam projects and low-effort submissions
- Build reputation as a premium platform for serious game developers

**System Stability**
- Control user growth to prevent server overload
- Test and optimize platform performance with manageable user base
- Gather feedback and iterate quickly with engaged early adopters

**Community Building**
- Foster tight-knit community of passionate game developers
- Encourage meaningful connections and collaborations
- Create exclusivity that drives demand and word-of-mouth marketing

### Invite System Mechanics

**Invite Types**
- **Creator Invites**: For established game designers with portfolios
- **Contributor Invites**: For artists, writers, sculptors, etc.
- **General Invites**: For fans and community members
- **VIP Invites**: For industry professionals and influencers

**Invite Allocation**
- **New Users**: Receive 3 invites after completing first project milestone
- **Active Creators**: Earn 2 additional invites per successful project
- **Top Contributors**: Receive 5 invites quarterly based on quality ratings
- **Platform Champions**: Special allocation for community leaders

### Growth Phases

**Phase 1: Closed Alpha (0-100 users)**
- Hand-picked industry professionals and friends
- Focus on core functionality testing
- Direct feedback channels with development team
- Weekly check-ins and feature prioritization

**Phase 2: Invite Beta (100-1,000 users)**
- Invite-only expansion through existing users
- Quality-focused growth with application review
- Community features and social mechanics
- Performance optimization and scaling tests

**Phase 3: Controlled Beta (1,000-5,000 users)**
- Increased invite allocation per user
- Waitlist integration and batch invitations
- Advanced features rollout
- Preparation for public launch

**Phase 4: Public Launch**
- Open registration with optional invite codes for benefits
- Referral program replaces invite system
- Focus on user acquisition and growth marketing
- Enterprise and partnership opportunities

## 6. Revenue Model & Pricing

### Zero Budget Philosophy & Competitive Advantage

#### Building on a Shoestring
- **Lean Development**: Platform built with minimal upfront capital using modern, cost-effective tools
- **Open Source First**: Leveraging free and open-source technologies (Supabase, Vercel, etc.)
- **Community-Driven Growth**: Organic growth through user value, not expensive marketing
- **Bootstrap Approach**: Self-funded through early marketplace sales, avoiding VC pressure for high margins

#### Platform Fees (Competitive & Transparent)
- **3%** of successful milestone funding (lower than industry standard 5-8%)
- **2%** of final product sales through platform (significantly lower than typical 5-10%)
- **Payment processing fees** (2.9% + 30¢) passed through at cost - no markup
- **Marketplace Sales**: 8% commission (competitive with Itch.io's 10% and much lower than app stores' 30%)

#### Industry Comparison
- **Kickstarter**: 5% + 3-5% payment processing = 8-10% total
- **Indiegogo**: 5% + 2.9% + 30¢ payment processing = ~8% total
- **Gumroad**: 3.5-8.5% + payment processing = 6-11% total
- **Itch.io**: 10% (can be reduced to 0% but default is 10%)
- **App Stores**: 30% (15% for small developers)

**Budget Zero**: 3% milestone + 8% marketplace = Industry-leading low fees

### Value-Added Services (One-time fees)
- **Project Promotion Package** ($49 one-time): Featured placement, social media promotion, press kit
- **Professional Portfolio** ($29 one-time): Custom website with lifetime hosting
- **Verified Professional Badge** ($19 one-time): Identity verification and search priority

### Additional Revenue Streams
- **Digital Marketplace Sales**: Primary revenue driver allowing lower platform fees
- **Educational courses** on game design and development (community-priced)
- **Professional consultations** and project reviews (community rates $25-75/hour)
- **Enterprise solutions** for established game companies (custom pricing)

### Transparent Fee Philosophy
- **No Hidden Costs**: All fees clearly displayed upfront
- **Cost-Plus Pricing**: Platform fees cover operational costs + modest sustainability margin
- **Community First**: Profits reinvested in platform improvements and community features
- **Open Financial Model**: Annual transparency reports on platform costs and revenue allocation

## 7. Legal & Compliance Framework

### Intellectual Property Management
- **IP Ownership Structure**: Clear framework for who owns what at each milestone
- **Licensing Agreements**: Standard templates for different collaboration types
- **Copyright Protection**: Automated registration and tracking of creative assets
- **Trademark Support**: Guidance for game name and brand protection
- **Open Source Options**: Support for Creative Commons and open licensing

### Tax & Financial Compliance
- **1099 Generation**: Automatic tax documents for contributors earning $600+
- **International Payments**: Currency conversion and tax withholding
- **Sales Tax Handling**: Automated collection for digital and physical sales
- **Creator Business Structure**: Guidance on LLC/corporation formation
- **Financial Reporting**: Compliance with crowdfunding regulations

### Platform Legal Structure
- **Terms of Service**: Comprehensive user agreements and platform rules
- **Privacy Policy**: GDPR, CCPA, and international data protection compliance
- **Dispute Resolution**: Mediation and arbitration processes for conflicts
- **Content Moderation**: Community guidelines and enforcement procedures
- **Age Verification**: COPPA compliance for users under 13

## 8. Quality Assurance & Operations

### Project Quality Standards
- **Project Review Process**: Multi-stage approval for new projects and milestones
- **Creator Verification**: Portfolio review and identity confirmation for project creators
- **Milestone Validation**: Community and expert review of milestone deliverables
- **Progress Monitoring**: Automated tracking of project activity and milestone completion rates

### Anti-Fraud Measures
- **Identity Verification**: KYC requirements for creators handling significant funding
- **Plagiarism Detection**: Automated scanning for copied content and assets
- **Financial Monitoring**: Unusual payment pattern detection and investigation
- **Community Reporting**: Easy reporting system for suspicious projects or behavior

### Customer Support & Community Management
- **Multi-Channel Support**: In-app chat, email, and community forums
- **Community Guidelines**: Clear behavioral expectations and consequences
- **Dispute Resolution**: Professional mediation for project conflicts
- **User Education**: Comprehensive tutorials and best practice guides

## 9. Technical Architecture

**All technical implementation details, code examples, and architectural decisions are documented in [BUILD_ROADMAP.md](BUILD_ROADMAP.md).**

### Design Philosophy

**Minimalist Design Principles**
- **White Space First**: Generous spacing between elements to reduce cognitive load
- **Single Focus**: Each page has one primary action or piece of content
- **Clean Typography**: Consistent hierarchy using 2-3 font weights maximum
- **Subtle Interactions**: Hover states and micro-animations enhance, never distract
- **Progressive Disclosure**: Show only essential information, reveal details on demand

**Navigation Philosophy - "Web of Connections"**
- **User-Centric**: Every page connects logically to user goals
- **Contextual**: Related information is always one click away
- **Progressive**: Complex features revealed as users need them
- **Collaborative**: Easy transitions between individual and team views

### Core Technical Principles

**Performance First**
- Lightning-fast page loads and interactions
- Minimal JavaScript bundles
- GPU-accelerated animations where beneficial
- Progressive enhancement over complexity

**Zero Vendor Lock-in**
- Standard web technologies and protocols
- Database-agnostic architecture
- Migration-ready from day one
- No proprietary APIs or services

**Local-First Development**
- Full offline development capability
- No external dependencies during development
- Production deployment flexibility
- Cost optimization through smart architecture choices

**Data Portability & Freedom**
- Complete data export capabilities
- Webhook integration for third-party platforms
- No vendor lock-in architecture
- User owns all their content and assets

**Multi-Platform Access**
- Responsive web application
- Mobile-optimized experience
- Offline capabilities where beneficial
- Cross-device synchronization

**Implementation Details**

All technical specifications, code examples, database schemas, API designs, and implementation details are documented in [BUILD_ROADMAP.md](BUILD_ROADMAP.md).

  
  async query<T>(sql: string, params?: any[]): Promise<T[]> {
    // Use pg library directly, not Supabase SDK
    const client = new Client({ connectionString: this.connectionString });
    await client.connect();
    try {
      const result = await client.query(sql, params);
      return result.rows;
    } finally {
      await client.end();
    }
  }
  
  // ... other methods
}

// Usage in application code
const db = new PostgreSQLClient(process.env.DATABASE_URL);
const users = await db.query<User>('SELECT * FROM users WHERE status = $1', ['active']);
```

**Authentication System (Supabase-Independent)**
```typescript
// Custom auth service using standard JWT
import jwt from 'jsonwebtoken';
import bcrypt from 'bcrypt';

class AuthService {
  private jwtSecret = process.env.JWT_SECRET!;
  
  async createUser(email: string, password: string): Promise<User> {
    const hashedPassword = await bcrypt.hash(password, 12);
    
    const user = await db.queryOne<User>(
      'INSERT INTO users (email, password_hash) VALUES ($1, $2) RETURNING *',
      [email, hashedPassword]
    );
    
    return user!;
  }
  
  async signIn(email: string, password: string): Promise<{ user: User; token: string }> {
    const user = await db.queryOne<User>(
      'SELECT * FROM users WHERE email = $1',
      [email]
    );
    
    if (!user || !await bcrypt.compare(password, user.password_hash)) {
      throw new Error('Invalid credentials');
    }
    
    const token = jwt.sign(
      { userId: user.id, email: user.email },
      this.jwtSecret,
      { expiresIn: '7d' }
    );
    
    return { user, token };
  }
  
  verifyToken(token: string): { userId: string; email: string } {
    return jwt.verify(token, this.jwtSecret) as any;
  }
}
```

**Storage Abstraction Layer**
```typescript
// Storage interface supporting multiple providers
interface StorageProvider {
  uploadFile(key: string, file: Buffer, contentType: string): Promise<string>;
  deleteFile(key: string): Promise<void>;
  getSignedUrl(key: string, expiresIn: number): Promise<string>;
}

// Supabase Storage implementation
class SupabaseStorageProvider implements StorageProvider {
  constructor(private supabaseUrl: string, private supabaseKey: string) {}
  
  async uploadFile(key: string, file: Buffer, contentType: string): Promise<string> {
    // Use Supabase REST API directly, not SDK
    const response = await fetch(`${this.supabaseUrl}/storage/v1/object/project-assets/${key}`, {
      method: 'POST',
      headers: {
        'Authorization': `Bearer ${this.supabaseKey}`,
        'Content-Type': contentType,
      },
      body: file,
    });
    
    if (!response.ok) throw new Error('Upload failed');
    return `${this.supabaseUrl}/storage/v1/object/public/project-assets/${key}`;
  }
}

// AWS S3 implementation (for migration)
class S3StorageProvider implements StorageProvider {
  constructor(private s3Client: AWS.S3, private bucketName: string) {}
  
  async uploadFile(key: string, file: Buffer, contentType: string): Promise<string> {
    const result = await this.s3Client.upload({
      Bucket: this.bucketName,
      Key: key,
      Body: file,
      ContentType: contentType,
    }).promise();
    
    return result.Location;
  }
}

// Storage service with provider switching
class StorageService {
  constructor(private provider: StorageProvider) {}
  
  async uploadProjectAsset(projectId: string, file: Buffer, contentType: string): Promise<string> {
    const key = `projects/${projectId}/${Date.now()}-${Math.random()}`;
    return this.provider.uploadFile(key, file, contentType);
  }
}

// Environment-based provider selection
const storageProvider = process.env.STORAGE_PROVIDER === 'aws' 
  ? new S3StorageProvider(s3Client, process.env.S3_BUCKET!)
  : new SupabaseStorageProvider(process.env.SUPABASE_URL!, process.env.SUPABASE_ANON_KEY!);

const storage = new StorageService(storageProvider);
```

**Real-time Features (WebSocket-Based)**
```typescript
// Custom WebSocket server instead of Supabase Realtime
import { WebSocketServer } from 'ws';

class RealtimeService {
  private wss: WebSocketServer;
  private clients = new Map<string, Set<WebSocket>>();
  
  constructor(port: number) {
    this.wss = new WebSocketServer({ port });
    this.setupEventHandlers();
  }
  
  subscribeToProject(projectId: string, ws: WebSocket, userId: string) {
    if (!this.clients.has(projectId)) {
      this.clients.set(projectId, new Set());
    }
    this.clients.get(projectId)!.add(ws);
    
    ws.on('close', () => {
      this.clients.get(projectId)?.delete(ws);
    });
  }
  
  broadcastToProject(projectId: string, event: any) {
    const projectClients = this.clients.get(projectId);
    if (projectClients) {
      const message = JSON.stringify(event);
      projectClients.forEach(ws => {
        if (ws.readyState === WebSocket.OPEN) {
          ws.send(message);
        }
      });
    }
  }
}
```

**Collaborative Rulebook Editor Implementation (Vanilla TypeScript + ProseMirror)**
```typescript
// Real-time collaborative editing using Yjs CRDT + ProseMirror
import { EditorState } from 'prosemirror-state';
import { EditorView } from 'prosemirror-view';
import { Schema } from 'prosemirror-model';
import * as Y from 'yjs';
import { ySyncPlugin, yCursorPlugin } from 'y-prosemirror';

interface RulebookOperation {
  type: 'insert' | 'delete' | 'retain';
  length?: number;
  text?: string;
  position: number;
  userId: string;
  timestamp: number;
}

class CollaborativeRulebookEditor {
  private editorView: EditorView;
  private rulebookId: string;
  private userId: string;
  private websocket: WebSocket;
  private pendingOperations: RulebookOperation[] = [];
  
  constructor(container: HTMLElement, rulebookId: string, userId: string) {
    this.rulebookId = rulebookId;
    this.userId = userId;
    
    // Initialize ProseMirror editor with game-specific schema
    const gameSchema = new Schema({
      nodes: {
        doc: { content: 'block+' },
        paragraph: { content: 'inline*', group: 'block' },
        text: { group: 'inline' },
        // Game-specific nodes
        gameComponent: {
          content: 'inline*',
          group: 'block',
          attrs: { componentType: { default: 'card' }, quantity: { default: 1 } }
        },
        ruleMechanic: {
          content: 'inline*', 
          group: 'block',
          attrs: { complexity: { default: 'simple' } }
        }
      },
      marks: {
        strong: {},
        em: {},
        ruleReference: { attrs: { targetSection: {} } }
      }
    });
    
    // Create Yjs document for collaboration
    const ydoc = new Y.Doc();
    const yXmlFragment = ydoc.getXmlFragment('prosemirror');
    
    this.editorView = new EditorView(container, {
      state: EditorState.create({
        schema: gameSchema,
        plugins: [
          ySyncPlugin(yXmlFragment),
          yCursorPlugin(this.provider.awareness),
          // Custom game design plugins
          componentLinkingPlugin(),
          ruleValidationPlugin()
        ]
      })
    });
    
    this.connectWebSocket();
  }
  
  private connectWebSocket() {
    this.websocket = new WebSocket(`ws://localhost:3001/rulebook/${this.rulebookId}`);
    
    this.websocket.onmessage = (event) => {
      const operation = JSON.parse(event.data) as RulebookOperation;
      this.applyRemoteOperation(operation);
    };
  }
  
  private handleDocumentChange(update: any) {
    // Convert CodeMirror changes to operations
    const operations = this.convertChangesToOperations(update.changes);
    
    // Send operations to other collaborators
    operations.forEach(op => {
      this.websocket.send(JSON.stringify({
        ...op,
        userId: this.userId,
        rulebookId: this.rulebookId
      }));
    });
  }
  
  private applyRemoteOperation(operation: RulebookOperation) {
    // Apply remote user's changes to local editor
    if (operation.userId === this.userId) return; // Skip own operations
    
    const transaction = this.editorView.state.update({
      changes: this.operationToChange(operation)
    });
    
    this.editorView.dispatch(transaction);
  }
}

// Rulebook template system
class RulebookTemplateManager {
  static getTemplate(gameType: string): RulebookTemplate {
    const templates: Record<string, RulebookTemplate> = {
      'Board Game': {
        sections: [
          { title: 'Game Overview', content: 'Brief description of the game theme and objective.' },
          { title: 'Components', content: 'List all game components and their quantities.' },
          { title: 'Setup', content: 'Step-by-step setup instructions.' },
          { title: 'Gameplay', content: 'How the game is played, turn structure.' },
          { title: 'Winning the Game', content: 'Victory conditions and end game triggers.' },
          { title: 'Variants', content: 'Optional rules and game variations.' }
        ]
      },
      'Card Game': {
        sections: [
          { title: 'Overview', content: 'Game theme, players, and basic objective.' },
          { title: 'Card Types', content: 'Description of different card types and their functions.' },
          { title: 'Setup', content: 'How to prepare and deal cards.' },
          { title: 'Playing the Game', content: 'Turn sequence and card play rules.' },
          { title: 'Scoring', content: 'How points are earned and calculated.' },
          { title: 'End Game', content: 'When and how the game ends.' }
        ]
      },
      'RPG': {
        sections: [
          { title: 'Introduction', content: 'Setting, theme, and core concepts.' },
          { title: 'Character Creation', content: 'How to create player characters.' },
          { title: 'Game Mechanics', content: 'Core resolution system and dice mechanics.' },
          { title: 'Combat', content: 'Combat rules and procedures.' },
          { title: 'Magic/Special Abilities', content: 'Supernatural powers and abilities.' },
          { title: 'Equipment', content: 'Weapons, armor, and gear.' },
          { title: 'Gamemaster Section', content: 'Guidance for running the game.' }
        ]
      }
    };
    
    return templates[gameType] || templates['Board Game'];
  }
}

// Version control for rulebooks
class RulebookVersionControl {
  async createVersion(rulebookId: string, content: string, summary: string): Promise<string> {
    const version = await db.queryOne<RulebookVersion>(
      `INSERT INTO rulebook_versions (rulebook_id, content_snapshot, change_summary, created_by, version_number)
       VALUES ($1, $2, $3, $4, $5) RETURNING *`,
      [rulebookId, content, summary, this.userId, await this.getNextVersionNumber(rulebookId)]
    );
    
    return version!.id;
  }
  
  async compareVersions(versionA: string, versionB: string): Promise<RulebookChange[]> {
    // Implement diff algorithm to show changes between versions
    const contentA = await this.getVersionContent(versionA);
    const contentB = await this.getVersionContent(versionB);
    
    return this.computeDiff(contentA, contentB);
  }
  
  async revertToVersion(rulebookId: string, versionId: string): Promise<void> {
    const version = await this.getVersion(versionId);
    
    await db.query(
      'UPDATE rulebooks SET content = $1, version = $2 WHERE id = $3',
      [version.content_snapshot, version.version_number, rulebookId]
    );
  }
}

// Component linking system
class ComponentRuleLinker {
  async linkComponentToRule(componentId: string, sectionId: string, ruleText: string): Promise<void> {
    await db.query(
      `INSERT INTO component_rule_links (component_id, section_id, rule_reference)
       VALUES ($1, $2, $3)`,
      [componentId, sectionId, ruleText]
    );
  }
  
  async getLinkedComponents(sectionId: string): Promise<GameComponent[]> {
    return db.query<GameComponent>(
      `SELECT gc.* FROM game_components gc
       JOIN component_rule_links crl ON gc.id = crl.component_id
       WHERE crl.section_id = $1`,
      [sectionId]
    );
  }
  
  async generateComponentList(rulebookId: string): Promise<GameComponent[]> {
    // Auto-generate component list based on rules content
    const sections = await this.getRulebookSections(rulebookId);
    const mentionedComponents = this.extractComponentMentions(sections);
    
    return mentionedComponents;
  }
}

// Professional PDF Export System
import { PDFDocument, rgb, StandardFonts } from 'pdf-lib';
import { marked } from 'marked';

interface PDFExportOptions {
  format: 'A4' | 'Letter' | 'A5' | 'Custom';
  includeTableOfContents: boolean;
  includeGlossary: boolean;
  includeIndex: boolean;
  includeCoverPage: boolean;
  theme: 'Standard' | 'Minimal' | 'Professional' | 'Custom';
  customBranding?: {
    logo?: Buffer;
    colors?: { primary: string; secondary: string; accent: string; };
    fonts?: { heading: string; body: string; };
  };
  margins: { top: number; bottom: number; left: number; right: number; };
  includePrintMarks: boolean;
  includeBleed: boolean;
}

class RulebookPDFExporter {
  async exportToPDF(rulebookId: string, options: PDFExportOptions): Promise<Buffer> {
    const pdfDoc = await PDFDocument.create();
    const rulebook = await this.getRulebook(rulebookId);
    const sections = await this.getRulebookSections(rulebookId);
    
    // Add custom fonts if specified
    const fonts = await this.loadFonts(pdfDoc, options.customBranding?.fonts);
    
    // Generate cover page
    if (options.includeCoverPage) {
      await this.addCoverPage(pdfDoc, rulebook, options, fonts);
    }
    
    // Generate table of contents
    if (options.includeTableOfContents) {
      await this.addTableOfContents(pdfDoc, sections, options, fonts);
    }
    
    // Process each section
    for (const section of sections) {
      await this.addSection(pdfDoc, section, options, fonts);
    }
    
    // Add glossary
    if (options.includeGlossary) {
      const glossary = await this.getGlossaryTerms(rulebookId);
      await this.addGlossary(pdfDoc, glossary, options, fonts);
    }
    
    // Add index
    if (options.includeIndex) {
      await this.addIndex(pdfDoc, sections, options, fonts);
    }
    
    // Add print marks for professional printing
    if (options.includePrintMarks) {
      await this.addPrintMarks(pdfDoc, options);
    }
    
    return Buffer.from(await pdfDoc.save());
  }
  
  private async addCoverPage(pdfDoc: PDFDocument, rulebook: Rulebook, options: PDFExportOptions, fonts: any) {
    const page = pdfDoc.addPage();
    const { width, height } = page.getSize();
    
    // Add logo if provided
    if (options.customBranding?.logo) {
      const logoImage = await pdfDoc.embedPng(options.customBranding.logo);
      const logoScale = Math.min(width * 0.3 / logoImage.width, height * 0.2 / logoImage.height);
      page.drawImage(logoImage, {
        x: (width - logoImage.width * logoScale) / 2,
        y: height * 0.8,
        width: logoImage.width * logoScale,
        height: logoImage.height * logoScale,
      });
    }
    
    // Add title
    page.drawText(rulebook.title, {
      x: 50,
      y: height * 0.6,
      size: 36,
      font: fonts.heading,
      color: rgb(0, 0, 0),
    });
    
    // Add description
    page.drawText(rulebook.description, {
      x: 50,
      y: height * 0.4,
      size: 14,
      font: fonts.body,
      color: rgb(0.3, 0.3, 0.3),
      maxWidth: width - 100,
    });
  }
  
  private async addSection(pdfDoc: PDFDocument, section: RulebookSection, options: PDFExportOptions, fonts: any) {
    const page = pdfDoc.addPage();
    const { width, height } = page.getSize();
    
    // Convert markdown to styled text
    const htmlContent = marked(section.content);
    const styledText = this.convertHTMLToStyledText(htmlContent);
    
    // Add section title
    page.drawText(section.title, {
      x: options.margins.left,
      y: height - options.margins.top - 30,
      size: 24,
      font: fonts.heading,
      color: rgb(0, 0, 0),
    });
    
    // Add section content with proper styling
    await this.addStyledContent(page, styledText, options, fonts);
    
    // Add linked components if any
    const linkedComponents = await this.getLinkedComponents(section.id);
    if (linkedComponents.length > 0) {
      await this.addComponentsSection(page, linkedComponents, options, fonts);
    }
  }
  
  async exportForPrint(rulebookId: string): Promise<Buffer> {
    return this.exportToPDF(rulebookId, {
      format: 'A4',
      includeTableOfContents: true,
      includeGlossary: true,
      includeIndex: true,
      includeCoverPage: true,
      theme: 'Professional',
      margins: { top: 72, bottom: 72, left: 72, right: 72 }, // 1 inch margins
      includePrintMarks: true,
      includeBleed: true,
    });
  }
  
  async exportForDigital(rulebookId: string): Promise<Buffer> {
    return this.exportToPDF(rulebookId, {
      format: 'A4',
      includeTableOfContents: true,
      includeGlossary: true,
      includeIndex: false,
      includeCoverPage: true,
      theme: 'Standard',
      margins: { top: 36, bottom: 36, left: 36, right: 36 },
      includePrintMarks: false,
      includeBleed: false,
    });
  }
}

// Webhook System Implementation
import crypto from 'crypto';
import { Queue } from 'bull';

class WebhookService {
  private webhookQueue: Queue;
  
  constructor() {
    this.webhookQueue = new Queue('webhook delivery', {
      redis: { host: 'localhost', port: 6379 },
      defaultJobOptions: {
        removeOnComplete: 100,
        removeOnFail: 50,
        attempts: 5,
        backoff: { type: 'exponential', delay: 2000 }
      }
    });
    
    this.setupQueueProcessor();
  }
  
  // Register a new webhook endpoint
  async registerWebhook(userId: string, config: WebhookEndpointConfig): Promise<WebhookEndpoint> {
    const secretKey = crypto.randomBytes(32).toString('hex');
    
    const webhook = await db.queryOne<WebhookEndpoint>(
      `INSERT INTO webhook_endpoints (user_id, project_id, name, url, secret_key, event_types, retry_config, headers)
       VALUES ($1, $2, $3, $4, $5, $6, $7, $8) RETURNING *`,
      [
        userId,
        config.projectId,
        config.name,
        config.url,
        secretKey,
        JSON.stringify(config.eventTypes),
        JSON.stringify(config.retryConfig || { max_retries: 3, retry_delays: [1000, 5000, 15000] }),
        JSON.stringify(config.headers || {})
      ]
    );
    
    return webhook!;
  }
  
  // Trigger webhook events
  async triggerEvent(event: WebhookEventData): Promise<void> {
    // Store the event
    await db.query(
      `INSERT INTO webhook_events (event_type, resource_type, resource_id, user_id, project_id, data, timestamp)
       VALUES ($1, $2, $3, $4, $5, $6, $7)`,
      [event.eventType, event.resourceType, event.resourceId, event.userId, event.projectId, JSON.stringify(event.data), new Date()]
    );
    
    // Find matching webhook endpoints
    const endpoints = await this.getMatchingEndpoints(event.userId, event.projectId, event.eventType);
    
    // Queue delivery jobs for each endpoint
    for (const endpoint of endpoints) {
      await this.queueWebhookDelivery(endpoint, event);
    }
  }
  
  private async queueWebhookDelivery(endpoint: WebhookEndpoint, event: WebhookEventData): Promise<void> {
    const payload = await this.buildWebhookPayload(event);
    const signature = this.generateSignature(payload, endpoint.secret_key);
    
    await this.webhookQueue.add('deliver', {
      endpointId: endpoint.id,
      url: endpoint.url,
      payload,
      signature,
      headers: endpoint.headers,
      eventType: event.eventType
    });
  }
  
  private async buildWebhookPayload(event: WebhookEventData): Promise<any> {
    const basePayload = {
      id: crypto.randomUUID(),
      event_type: event.eventType,
      timestamp: event.timestamp || new Date().toISOString(),
      resource_type: event.resourceType,
      resource_id: event.resourceId,
      user_id: event.userId,
      project_id: event.projectId
    };
    
    // Add complete resource data based on type
    switch (event.resourceType) {
      case 'Project':
        const project = await this.getProjectData(event.resourceId);
        return { ...basePayload, data: { project } };
        
      case 'Asset':
        const asset = await this.getAssetDataWithUrls(event.resourceId);
        return { ...basePayload, data: { asset } };
        
      case 'Milestone':
        const milestone = await this.getMilestoneData(event.resourceId);
        return { ...basePayload, data: { milestone } };
        
      default:
        return { ...basePayload, data: event.data };
    }
  }
  
  private async getAssetDataWithUrls(assetId: string): Promise<any> {
    const asset = await db.queryOne(
      'SELECT * FROM project_assets WHERE id = $1',
      [assetId]
    );
    
    if (!asset) return null;
    
    // Generate signed URLs for file access
    const downloadUrl = await this.generateSecureDownloadUrl(asset.file_url, asset.user_id);
    
    return {
      ...asset,
      download_url: downloadUrl,
      metadata: asset.metadata,
      file_size: asset.file_size,
      content_type: asset.content_type
    };
  }
  
  private generateSignature(payload: any, secretKey: string): string {
    const payloadString = JSON.stringify(payload);
    return crypto
      .createHmac('sha256', secretKey)
      .update(payloadString)
      .digest('hex');
  }
  
  private setupQueueProcessor(): void {
    this.webhookQueue.process('deliver', async (job) => {
      const { endpointId, url, payload, signature, headers, eventType } = job.data;
      
      try {
        const response = await fetch(url, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'X-BudgetZero-Signature': `sha256=${signature}`,
            'X-BudgetZero-Event': eventType,
            'User-Agent': 'BudgetZero-Webhooks/1.0',
            ...headers
          },
          body: JSON.stringify(payload),
          timeout: 10000  // 10 second timeout
        });
        
        // Record successful delivery
        await db.query(
          `INSERT INTO webhook_deliveries (endpoint_id, event_type, payload, payload_signature, status, http_status_code, delivered_at)
           VALUES ($1, $2, $3, $4, 'Delivered', $5, $6)`,
          [endpointId, eventType, JSON.stringify(payload), signature, response.status, new Date()]
        );
        
        // Update endpoint last successful delivery
        await db.query(
          'UPDATE webhook_endpoints SET last_successful_delivery = $1, failure_count = 0 WHERE id = $2',
          [new Date(), endpointId]
        );
        
      } catch (error) {
        // Record failed delivery
        await db.query(
          `INSERT INTO webhook_deliveries (endpoint_id, event_type, payload, payload_signature, status, retry_count)
           VALUES ($1, $2, $3, $4, 'Failed', $5)`,
          [endpointId, eventType, JSON.stringify(payload), signature, job.attemptsMade]
        );
        
        // Increment failure count
        await db.query(
          'UPDATE webhook_endpoints SET failure_count = failure_count + 1 WHERE id = $1',
          [endpointId]
        );
        
        throw error; // Re-throw to trigger retry
      }
    });
  }
}

// Data Export Service for Complete Platform Freedom
class DataExportService {
  async requestDataExport(userId: string, options: DataExportOptions): Promise<DataExportRequest> {
    const exportRequest = await db.queryOne<DataExportRequest>(
      `INSERT INTO data_export_requests (user_id, export_type, project_ids, include_assets, include_metadata, include_payment_history, format)
       VALUES ($1, $2, $3, $4, $5, $6, $7) RETURNING *`,
      [
        userId,
        options.exportType,
        JSON.stringify(options.projectIds || []),
        options.includeAssets,
        options.includeMetadata,
        options.includePaymentHistory,
        options.format
      ]
    );
    
    // Queue export processing
    await this.queueExportJob(exportRequest!.id);
    
    return exportRequest!;
  }
  
  async generateCompleteExport(userId: string): Promise<any> {
    const exportData = {
      user: await this.getUserData(userId),
      projects: await this.getUserProjects(userId),
      contributions: await this.getUserContributions(userId),
      marketplace_products: await this.getUserMarketplaceProducts(userId),
      payments: await this.getUserPaymentHistory(userId),
      webhooks: await this.getUserWebhooks(userId),
      export_metadata: {
        generated_at: new Date().toISOString(),
        format_version: '1.0',
        total_projects: 0,
        total_assets: 0
      }
    };
    
    // Add asset download URLs if requested
    if (options.includeAssets) {
      exportData.asset_download_urls = await this.generateAssetDownloadUrls(userId);
    }
    
    return exportData;
  }
  
  // Generate secure download URLs for all user assets
  private async generateAssetDownloadUrls(userId: string): Promise<any[]> {
    const assets = await db.query(
      `SELECT pa.* FROM project_assets pa 
       JOIN projects p ON pa.project_id = p.id 
       WHERE p.creator_id = $1 OR pa.uploaded_by = $1`,
      [userId]
    );
    
    return Promise.all(assets.map(async (asset) => ({
      asset_id: asset.id,
      filename: asset.filename,
      download_url: await this.generateSecureDownloadUrl(asset.file_url, userId),
      expires_at: new Date(Date.now() + 7 * 24 * 60 * 60 * 1000).toISOString() // 7 days
    })));
  }
}

interface WebhookEventData {
  eventType: WebhookEventType;
  resourceType: string;
  resourceId: string;
  userId: string;
  projectId?: string;
  data: any;
  timestamp?: Date;
}

// Example usage: Shopify Integration
class ShopifyIntegration {
  async syncProjectToShopify(projectId: string, shopifyWebhookUrl: string): Promise<void> {
    // When project completes, automatically create Shopify product
    const webhook = await webhookService.registerWebhook(userId, {
      name: 'Shopify Sync',
      url: shopifyWebhookUrl,
      eventTypes: ['project.completed', 'product.listed', 'asset.uploaded'],
      projectId: projectId
    });
    
    console.log(`Shopify sync enabled for project ${projectId}`);
  }
}
```

### Migration Strategy & Timeline

**Phase 1: Initial Development (Months 1-6)**
- Use Supabase for rapid development and validation
- Build all application logic with abstraction layers
- No direct Supabase SDK usage in core business logic
- Standard PostgreSQL queries and REST API calls

**Phase 2: Optimization (Months 6-12)**
- Monitor Supabase costs and performance
- Implement caching layers (Redis)
- Optimize database queries and connection pooling
- Prepare migration scripts and tooling

**Phase 3: Migration Preparation (Year 2)**
- When monthly Supabase costs exceed $500-1000
- Set up self-managed PostgreSQL (AWS RDS, Digital Ocean)
- Implement S3 or MinIO for file storage
- Set up monitoring and backup systems

**Phase 4: Migration Execution**
- Database migration using standard SQL dumps
- File migration using rsync or cloud transfer tools
- DNS switch for seamless transition
- Rollback plan in case of issues

### Cost Optimization Milestones

**Supabase Cost Thresholds:**
- **Free Tier**: $0/month (up to 500MB database, 1GB storage)
- **Pro Tier**: $25/month (up to 8GB database, 100GB storage)
- **Team Tier**: $599/month (up to 500GB database, 200GB storage)

**Migration Trigger Points:**
- **Database**: When approaching 8GB or needing more than 2 CPU cores
- **Storage**: When exceeding 100GB or needing CDN optimization
- **Bandwidth**: When transfer costs exceed $50/month
- **Function Calls**: When edge functions exceed 2M invocations/month

**Alternative Infrastructure Costs:**
- **Database**: AWS RDS PostgreSQL ~$50-200/month for similar specs
- **Storage**: AWS S3 ~$23/month for 1TB with CloudFront
- **Compute**: Vercel Pro ~$20/month + usage (can move to Railway, Fly.io)
- **Total Savings**: Potentially 60-80% reduction in infrastructure costs

### Scalability & Performance
- **Database Optimization**: Read replicas, connection pooling, and query optimization
- **Horizontal Scaling**: Auto-scaling groups for web servers and background workers
- **CDN Strategy**: Global content delivery for assets and static files
- **Monitoring & Observability**: Real-time tracking of performance and user analytics

## 10. Development Timeline & Milestones

### Phase 1: Foundation (Months 1-3)
**MVP Core Features**

**Month 1: Setup & Authentication**
- [ ] Development environment setup (Supabase, Vercel, GitHub)
- [ ] Basic authentication system with invite-only registration
- [ ] User profile creation and management
- [ ] Basic project creation and listing
- [ ] Simple payment processing integration (Stripe)

**Month 2: Core Platform**
- [ ] Milestone creation and management system
- [ ] Basic funding and contribution functionality
- [ ] Custom rich text editor with ProseMirror + WebGPU animations
- [ ] Rulebook templates for different game types
- [ ] Comment system for projects and milestones
- [ ] User dashboard and project management interface

**Month 3: Community Features**
- [ ] User search and discovery
- [ ] Portfolio system for contributors
- [ ] Basic recommendation system
- [ ] Notification system
- [ ] Mobile-responsive design

**Phase 1 Goals:**
- 50 alpha users (hand-picked industry professionals)
- 10 test projects with completed milestones
- Core functionality tested and refined
- Payment processing fully functional

### Phase 2: Enhanced Platform (Months 4-6)
**Community & Collaboration Features**

**Month 4: Advanced Community**
- [ ] Milestone discussion threads
- [ ] Community recommendation system
- [ ] Real-time collaborative rulebook editing (WebSocket implementation)
- [ ] Rulebook version control and change tracking
- [ ] Advanced search and filtering
- [ ] Project collaboration tools
- [ ] Real-time notifications and updates

**Month 5: Marketplace Foundation**
- [ ] Digital marketplace infrastructure
- [ ] Product listing and management
- [ ] Secure file delivery system
- [ ] Review and rating system
- [ ] Revenue split automation

**Month 6: Polish & Optimization**
- [ ] Mobile app development (React Native)
- [ ] Performance optimization and caching
- [ ] Advanced analytics and reporting
- [ ] Content moderation tools
- [ ] Beta testing program expansion

**Phase 2 Goals:**
- 500 beta users across all user types
- 50 active projects with community engagement
- First marketplace sales and revenue
- Mobile app beta release

### Phase 3: Scaling & Advanced Features (Months 7-9)
**Professional Tools & Scaling**

**Month 7: Professional Features**
- [ ] Advanced project management tools
- [ ] Asset versioning and collaboration
- [ ] Component linking system (rules to game pieces)
- [ ] Rulebook export tools (PDF, print-ready formats)
- [ ] Glossary management and term linking
- [ ] **Webhook system implementation** (data portability & third-party integrations)
- [ ] **Complete data export functionality** (anti-lock-in features)
- [ ] Professional portfolio websites
- [ ] Educational content platform
- [ ] API development for integrations

**Month 8: Marketplace Enhancement**
- [ ] Advanced marketplace features (bundles, discounts)
- [ ] Print-on-demand integration (The Gamecrafter)
- [ ] Multi-language support
- [ ] Advanced analytics dashboard
- [ ] Creator monetization tools

**Month 9: Enterprise & Partnerships**
- [ ] Enterprise accounts and features
- [ ] Educational institution partnerships
- [ ] Advanced reporting and analytics
- [ ] White-label platform options
- [ ] Scaling infrastructure

**Phase 3 Goals:**
- 2,000 active users
- 200 completed projects
- $50,000+ in marketplace revenue
- Enterprise partnerships established

### Phase 4: Public Launch (Months 10-12)
**Market Expansion & Growth**

**Month 10: Pre-Launch Preparation**
- [ ] Public marketing website
- [ ] Content marketing strategy implementation
- [ ] Press and media outreach
- [ ] Influencer partnership program
- [ ] Launch event planning

**Month 11: Public Beta**
- [ ] Open beta with waitlist management
- [ ] Community-driven growth features
- [ ] Advanced onboarding and tutorials
- [ ] Customer support infrastructure
- [ ] Legal compliance finalization

**Month 12: Full Public Launch**
- [ ] Public registration opens
- [ ] Marketing campaign launch
- [ ] Conference presentations and demos
- [ ] Community events and contests
- [ ] Growth optimization and scaling

**Phase 4 Goals:**
- 10,000+ registered users
- 1,000+ active projects
- $200,000+ annual marketplace revenue
- Industry recognition and partnerships

### Ongoing Development (Year 2+)
**Continuous Improvement & Expansion**

**Quarter 1: Advanced Features**
- [ ] AI-powered project matching and recommendations
- [ ] Advanced collaboration tools (video calls, screen sharing)
- [ ] International expansion (multi-currency, localization)
- [ ] Advanced creator analytics and insights

**Quarter 2: Platform Evolution**
- [ ] VR/AR integration for 3D asset preview
- [ ] Blockchain integration for digital asset ownership
- [ ] Advanced educational certification programs
- [ ] Corporate training and enterprise solutions

**Quarter 3: Market Expansion**
- [ ] Expansion beyond tabletop games (video games, digital art)
- [ ] Advanced manufacturing partnerships
- [ ] Investment and funding platform integration
- [ ] Global creator accelerator program

**Quarter 4: Innovation & Future**
- [ ] AI-assisted game design tools
- [ ] Advanced 3D printing integration
- [ ] Metaverse and virtual collaboration spaces
- [ ] Next-generation creator economy features

## Key Success Metrics

### User Engagement
- **Monthly Active Users (MAU)**: Target 10,000+ by end of Year 1
- **Project Completion Rate**: Target 70%+ of projects completing at least 3 milestones
- **Community Engagement**: Target 80%+ of users participating in discussions or recommendations
- **Retention Rate**: Target 60%+ 6-month user retention

### Financial Performance
- **Gross Marketplace Revenue**: Target $200,000+ in Year 1
- **Platform Revenue**: Target $50,000+ from milestone fees in Year 1
- **Average Project Value**: Target $2,000+ per completed project
- **Creator Satisfaction**: Target 90%+ creator satisfaction with earnings and experience

### Platform Health
- **Project Success Rate**: Target 80%+ of funded projects delivering promised milestones
- **Community Quality**: Target <5% projects requiring moderation intervention
- **Technical Performance**: Target 99.5%+ uptime and <2s average page load times
- **Support Quality**: Target <24h average response time for support requests

## Critical Missing Features Analysis

After reviewing our comprehensive plan, here are the **key gaps** that need to be addressed:

### **🚨 MUST HAVE (MVP Critical)**

**1. Playtesting Infrastructure**
- Virtual playtesting tables for remote game testing
- Structured feedback collection during gameplay
- Session recording and replay capabilities
- **Why Critical**: Playtesting is essential to game development - without it, games remain untested theories

**2. Basic Production Support** *(Simplified)*
- Integration with The Gamecrafter for print-on-demand
- Simple component specification templates
- Basic cost estimation tools
- **Why Important**: Provides publishing path without complex manufacturing management

**3. Professional PDF Export**
- Print-ready rulebook generation with proper formatting
- Multiple export formats (digital, print, accessibility)
- Custom branding and layout options
- **Why Critical**: Professional deliverable for completed projects

### **⚡ HIGH PRIORITY (Competitive Advantage)**

**4. Advanced Asset Management**
- Built-in design tools for cards and components
- Template library and design collaboration
- Version control for visual assets
- **Why Important**: Differentiates from generic project platforms

**5. Analytics Dashboard**
- Project performance tracking and insights
- Community engagement metrics
- ROI calculations for contributors
- **Why Important**: Data-driven optimization for creators

**6. Professional Services Marketplace**
- Vetted freelancer network integration
- Skill verification and service booking
- Escrow services for professional work
- **Why Important**: Revenue opportunity and professional credibility

### **📈 GROWTH FEATURES (Scale & Retention)**

**7. Educational Platform**
- Game development tutorials and mentorship
- Skill certification programs
- Resource libraries and best practices
- **Why Valuable**: Community growth and creator development

**8. Competition & Events System**
- Design competitions and game jams
- Virtual showcase events
- Community challenges and awards
- **Why Valuable**: Engagement and content generation

**9. Advanced Communication**
- Integrated video conferencing and collaboration
- Voice messaging and live streaming
- Multi-language support
- **Why Valuable**: Enhanced collaboration experience

### **Implementation Priority:**

**Phase 1 (Months 1-3):** PDF Export + Basic Playtesting + Webhook System
**Phase 2 (Months 4-6):** Asset Management + Analytics + Communication Tools  
**Phase 3 (Months 7-9):** Professional Services + Educational Platform + Events
**Phase 4 (Months 10-12):** The Gamecrafter Integration + AI Features + International Expansion

### **Current Plan Status:**
✅ **Strong Foundation**: Collaborative rulebook editor, milestone system, marketplace
✅ **Technical Architecture**: Migration-ready, scalable infrastructure  
✅ **Business Model**: Sustainable, transparent, zero-budget aligned
⚠️ **Missing**: Webhook system (data portability), playtesting infrastructure, professional tools

The plan is **90% complete** with a clear focus on digital-first development and data portability. Manufacturing complexity deferred to focus on core platform value.

---

*This comprehensive analysis identifies the remaining gaps to make Budget Zero the definitive platform for collaborative tabletop game development, combining zero-budget accessibility with professional-grade tools and community-driven innovation.*
